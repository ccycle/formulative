# private memo

- 設計思想
  - 本来ならば設定ファイルで方程式を記述できるとよい
    - しかし設定ファイルだと記述に限界がある
      - 考えうる問題:
        - 設定ファイルで記述すると文法エラーを検出しにくい(コンパイルエラーで出してくれるのが理想)
        - 必然的に「設定で記述できるすべての方程式系」についてのコンパイルが必要
          - 「なんでも記述できる設定ファイル」を基にしたプログラムはコンパイル時間が爆発的に増加する(可能性)
    - ある程度設定ファイルに関しては自由度を下げてもいいのではないか？
      - 例えば動かしたいパラメータのみを書くなど
      - mainファイルを書く必要があるがそのあたりはユーザーに頑張って書いてもらうようにする
        - コンパイラーがおかしな記述を防いでくれるというメリットはある

- どう実装するのか
  - 上で述べたような設計思想に基づく実装方法を考えてみる
    - 入力データ(メッシュやパラメータなど)に対し前処理をする
    - 方程式を解く
    - 結果を出力する
  - これらの手順はODEとPDEで共通
    - 型クラスとして実装可能？

- 実装のチェックについて
  - 「すべての要素について0でない」などの条件を入れ込む必要あり
    - liquid haskellを使うのはどうか？
      - Haskellにおける型システムは「条件(...)を満たす集合」みたいなものを作り出すことができない
        - そのせいで「入力の失敗」をモナドで表現しなければならなくなる
          - モナドがあらゆるところに出てきて煩雑になる
            - 実行前に検査が可能
      - liquid haskellについて
        - 篩型(refinement type)によって制約を記述することができる
          - 例: 「0でないInt型」
            - 記述例: ` {-@ safeDiv2 :: (Eq a, Fractional a) => a -> { v: a | v /= 0 } -> a @-} `
              - 既存のコードに書き足すだけでよい
                - 色々と設定を頑張るとstack buildのときにチェックが走る
      - liquid haskellとHLSの相性が悪いのかめちゃくちゃクラッシュする
        - liquid haskellの採用は一旦保留
      - refined packageを使う
        - 篩型(refinement type)を使った実装
- 数値計算の時間刻みについて
  - 本来時間刻み幅は人間が調整すべきものではない
    - 元の方程式の振る舞いを見たいわけだから、入力は方程式のみであるべき
      - 時間刻み幅は職人芸的な技が絡んでくる
        - これをなくしたい
          - 刻み幅をadaptiveに変化
          - dataの構造をadaptiveに特化
            - 出力するデータも可変刻みで出力
            - 可視化の際には線形補間で等間隔のデータに直す
            - 平衡状態になったら計算を止めるなどの工夫もあると良いかも
              - 判定条件は？
                - 汎関数の値によって決定(？)

- 外微分の実装について
  - n次元n-formの微分を0にしたい
    - 行列のサイズを0にすれば可能？
    - むしろ行列の中身が0のものを作成したほうがいい？
      - 空リストを空のsimplexとみなして実装するとか
        - そうなると行列のサイズは $1 \times p$とかになる(？)

- 時間刻みを自分で設定しなくてもいいような作りにしたい
  - 関数の変化が急激なところは細かく、緩やかなところは粗く計算
  - 可視化は可変刻みの結果を元に補間などを使って等間隔に直す

- データの格納について
  - ReaderT design patternをもとに作る
    - 参考:
      - https://scrapbox.io/haskell-shoen/HKD
      - https://scrapbox.io/LugendrePublic/ReaderT_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3(%E7%BF%BB%E8%A8%B3)
        - https://scrapbox.io/haskell-shoen/ReaderT
          > また、例外処理とも相性がよく、IORefやTVarなどの参照をReaderTで共有するという設計「ReaderTパターン」は並行プログラミングと非常に相性がよい。これを主軸として作られた[http://hackage.haskell.org/package/unliftio unliftio]というライブラリではReaderTに対応したAPIが一通り揃っており、それに基づいたP派生として[rio]という[Prelude代替]もある。
  - fused-effectsというライブラリが便利そう
    - 副作用を組み合わせて使うならおそらくこれが最も使いやすい(可能性)
      - 速度がmtlとほぼ同速、Has ()... と書くことでinstanceをいちいち書かなくて良くなる
- Fieldの実装について
  - 割り算が出来ない条件をnonzeroではなくdividableみたいにnonzeroとわけるべきか？
    - 例えばdual numberだと実数部が0でないことが条件(実数部と双対基底部分がどちらもnonzeroであるというわけではない)
- prop_func : 関数のテスト
  - なんらかの性質を持つ関数の集合を考えたいときには、まずその性質を関数で表現してテストを書く
    - tastyを使うのがいいかも
      - 例: Abelian group
        - 足し算が可換: (a+b)+c==a+(b+c)
        - これを関数で書いておいてあとでテストをする
- 多項式のEDSLを組む？
  - べき乗のベンチマークは書いておきたい
  - STRefで計算するのがいいのか？
    - 4乗の計算は2乗の計算を使いまわすとかすると効率良い？
- 多変数関数の場合に変分がうまくいくのかの検証
- fused-effectsを使ったHasパターンがFPCompleteのReaderTパターンでも動くか確認
- (^):: a -> Integer -> aの実装
- MultiplicativeからRingに名前を変更
- Additiveクラスはなくてもいい？
  - Monoidといったほうがわかりやすい？
  - AdditiveGroupだけでいいのか
    - max-plus代数はGroupではない
      - とすると色々細かく設定できる方が嬉しいかも

- FieldにDividableみたいなスマートコンストラクターをつけていた
  - これのせいで型クラスの導出の際に相当な負担がかかっている
    - 一回これを外した上であとからsafeな関数を宣言すればいい？
